```cpp
#include <iostream>
#include <vector>
#include <stack>
#include <cstring>
using namespace std;
int N, node_num, kase;
// define maxN 1e5+9;
const int maxN = 1e5 + 9;
stack <int> st;
vector <int> graph[maxN];
//bool check[maxN];
int par[maxN], dfn[maxN], low[maxN], times, adj1, adj2;
bool existInStack[maxN];
// 有像圖
void Strong_connect(int u) {
	times++;
	low[u] = times;
	dfn[u] = times;
	st.push(u);
	existInStack[u] = true;
	for (int i = 0; i < graph[u].size(); ++i) {
		
		int v = graph[u][i];
		if (dfn[v] == 0) {
			// dont need par
			Strong_connect(v);
			low[u] = min(low[v], low[u]);
		}
		// 判斷是否在stack 使其成為cycle
		else if (existInStack[v]) {
			low[u] = min(dfn[v], low[u]);
		}
	}
	if (low[u] == dfn[u]) {
		// 連同u一起pop掉
		/*int w = st.top();
		st.pop();
		while (w != u) {
			w = st.top();
			st.pop();
		}
		*/
		int w;
		do {
			w = st.top();
			st.pop();
			existInStack[w] = false;
		} while (w != u);
	}
}


int main() {
	cin >> N;
	while (N--) {
		cin >> node_num >> kase;
		for (int i = 1; i <= node_num; ++i) {
			graph[i].clear();
		}
		times = 0;
		int ans = 0;
		memset(existInStack, 0, sizeof(existInStack));
		memset(par, -1, sizeof(par));
		memset(dfn, 0, sizeof(dfn));
		memset(low, 0, sizeof(low));
		// strong_connect 只能用在 有像圖
		for (int i = 0; i < kase; ++i) {
			cin >> adj1 >> adj2;
			graph[adj1].push_back(adj2);
		}
		for (int i = 1; i <= node_num; ++i) {
			if (dfn[i] == 0) {
				++ans;
				Strong_connect(i);
			}
				
		}
		cout << ans << '\n';
	}



	return 0;
}

```
