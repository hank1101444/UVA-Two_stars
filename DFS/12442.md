### 有一個小鎮，裡面的居民每個人都只會給另一個人寄信，求把信寄給哪位居民可以讓最多人看到這封信，若有相同者則取較小者。   

### Input： 第一行為一整數 T，代表有 T 組測資，每組測資的第一行為一整數 N，接下來 N 行每行都有兩個整數 u、v，代表居民 u 會把信寄給居民 v。

### Output： 輸出寄信給誰可以讓最多的居民看到這封信，若有相同者則取較小者。

## 解題思路    
### DFS 模擬即可，由於會 TLE，所以進行一點剪枝，多使用一個陣列紀錄某位居民是否已經被模擬過了，若在前面被模擬過了則就不需要在模擬第一個寄信給這位居民了，因為前面模擬的是另一個居民會寄給這位居民，一定會比直接寄信給這位居民的人數還要多

# Problem : why bool faster than int??
```cpp
#include <iostream>
using namespace std;
#include <vector>

vector <int> email;
// why bool faster than int??
vector <bool> check, duplicate;
int T, N, u, v, sum, c = 1;
pair <int, int> mx;


void dfs(int _u) {
	if (email[_u] == -1)
		return;
	if (check[_u] == 0) {
		sum += 1;
		check[_u] = true;
		duplicate[_u] = true;
		dfs(email[_u]);
	}
}


int main() {
	ios::sync_with_stdio(0);
	cin.tie(0);
	cout.tie(0);

	cin >> T;
	while (T--) {
		cin >> N;
		sum = 0;
		mx = make_pair(0, 0);
		email.assign(N + 1, -1);
		duplicate.assign(N + 1, false);
		for (int i = 0; i < N; ++i) {
			cin >> u >>  v;
			email[u] = v;
		}
		for (int i = 1; i <= N; ++i) {	//error 0 要浪費
			if (duplicate[i] != 1) {
				check.assign(N + 1, false);	//error
				dfs(i);
				// 如果數量相同 則輸出數字小的人
				if (sum > mx.second) {
					mx.first = i;
					mx.second = sum;
				}
				sum = 0;
			}
		}
		cout << "Case " << c++ << ": " << mx.first << '\n';
	}

	return 0;
}
```
